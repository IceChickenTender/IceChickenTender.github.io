---
title: "[LLM/RAG] LangChain Agent - 도구 호출(Tool Calling) "
categories:
  - LLM/RAG
  - LangChain
tags:
  - LLM/RAG
  - LangChain
  
use_math: true  
toc: true
toc_sticky: true
toc_label: "LangChain Agent 도구 호출"
---

# 1. LangChain Agent - 도구 호출 개요

## 1.1 도구 호출이란?

도구 호출(Tool Calling)은 LangChain 에서 언어 모델이 외부 도구나 API 를 사용할 수 있게 해주는 중요한 기능입니다. 이를 통해 AI 모델은 실시간 정보 검색, 계산, 데이터베이스 쿼리 등 다양한 작업을 수행할 수 있습니다. 특히, 에이전트(Agent) 기반의 시스템을 만들 때 매우 중요한 역할을 하기 때문에 잘 알아둘 필요가 있습니다.

## 1.2 도구 호출의 중요성

1. 기능 확장 : 언어 모델의 능력을 크게 확장시킵니다. 모델은 자체적으로 가지고 있지 않은 저보나 기능에 접근할 수 있습니다.

2. 실시간 정보 접근 : 웹 검색 도구를 통해 최신 정보를 얻을 수 있어, 항상 최신의 답변을 제공할 수 있습니다.

3. 정확성 향상 : 계산기 도구나 데이터베이스 쿼리 도구를 사용하여 정확한 수치나 데이터를 얻을 수 있습니다.

4. 다양한 작업 수행 : 코드 실행, 파일 조작, API 호출 등 다양한 작업을 수행할 수 있습니다.

## 1.3 도구 호출의 작동 방식

1. 도구 정의 : 개발자가 사용할 도구들을 정의하고 설정합니다.

2. 프롬프트 설계 : 모델이 도구를 적절히 사용할 수 있도록 프롬프트를 설계합니다.

3. 모델 추론 : 언어 모델이 주어진 태스크를 분석하고 필요한 도구를 결정합니다.

4. 도구 호출 : 모델이 선택한 도구를 호출하고 결과를 받아옵니다.

5. 결과 통합 : 도구 호출의 결과를 모델의 응답에 통합합니다.

## 1.4 도구 호출의 예시

1. 웹 검색 : "2024년 올림픽 개최지는 어디인가요?"라는 질문에 웹 검색 도구를 호출하여 최신 정보를 찾습니다. 

2. 수학 계산 : "1에서 100가지의 소수의 합은?"이라는 질문에 계산기 도구를 사용하여 정확한 결과를 제공합니다.

3. 날씨 정보 : "오늘 서울의 날씨는 어떤가요?"라는 질문에 날씨 API 도구를 호출하여 실시간 날씨 정보를 얻습니다.

# 2. 랭체인 내장(pre-built) 도구

## 2.1 LangChain 의 내장 도구(Tools) 소개

도구(Tools)는 모델이 호출하도록 설계된 유틸리티입니다. 도구의 입력은 모델이 생성하도록 설계되었고, 출력은 모델에 다시 전달되도록 설계되었습니다. 툴킷(Toolkit)은 함께 사용되도록 의도된 도구들의 모음입니다.

LangChain 은 다양한 작업을 수행하기 위한 여러 내장 도구를 제공합니다. 이러한 도구들은 언어 모델의 기능을 확장하고 외부 데이터 소스와의 상호작용을 가능하게 합니다.

1. 검색 도구

	웹 검색을 실행하는 도구들입니다. 주요 검색 도구는 다음과 같습니다.

	- Bing Search (유료)
	- Brave Search (무료)
	- Google Search (유료)
	- Tavily Search (월 1000회 무료 검색)

	이러한 도구들은 URL, 스니펫, 제목 등의 데이터를 반환합니다.

2. 코드 인터프리터

	코드 실행 환경을 제공하는 도구들입니다.

	- Azure Container Apps dynamic sessions (Python 지원)
	- E2B Data Analysis (Python, JavaScript, R, Java 지원)

	이 도구들은 텍스트, 이미지 등의 결과를 반환할 수 있습니다.

3. 생산성 도구

	생산성 툴에서 작업을 자동화하는 도구들입니다.

	- Github Toolkit
	- Gmail Toolkit
	- Slack Toolkit

	이 도구들은 대부분 무료로 제공되지만, 사용량 제한이 있을 수 있습니다.

4. 웹 브라우징 도구

	웹 브라우저에서 작업을 자동화하는 도구들입니다.

	- PlayWright Browser Toolkit
	- Requests Toolkit

	이 도구들은 브라우저와의 상호작용을 지원하거나 HTTP 요청을 수행할 수 있습니다.

5. 데이터베이스 도구

	데이터베이스 작업을 자동화하는 도구들입니다.

	- SQLDatabase Toolkit
	- Spark SQL Toolkit

	이 도구들은 SQL 쿼리 실행 등의 데이터베이스 작업을 수행할 수 있습니다.

---

## 2.2 웹 검색 도구 활용

LangChain 의 웹 검색 도구인 Tavily API를 사용하여 실시간 금융 정보를 검색하고 분석에 활용하는 예제를 살펴보겠습니다.

### 0. Tavily API 인증키 발급

Tavily API 를 사용하여 LangChain 의 웹 검색 기능을 활용하기 위해서는 API 인증키가 필요합니다.

공식 Tavily 웹 사이트 (https://www.tavily.com/) 에 접속하고 인증키를 발급받습니다. (월 1000회 무료 사용 가능)

코랩 환경에 적용하기 위해 다음과 같이 적용하고 실행시켜 줍니다.

```python
import os

os.environ["TAVILY_API_KEY"] = "your_api_key"
```

### 1. 필요한 모듈 가져오기

```python
from langchain_community.tools import TavilySearchResults
```

`langchain_community.tools` 모듈에서 `TavilySearchResults` 클래스를 가져옵니다. 이 클래스는 Tavily API 를 사용하여 웹 검색을 수행합니다.

### 2. 검색 쿼리 설정

```python
query = "2025년 애플의 주가 전망에 대해서 분석하세요."
```

검색하고자 하는 내용을 무자열로 `query` 변수에 저장합니다. 이 예제에서는 2025년 애플의 주가 전망에 대한 분석을 요청합니다.

### 3. 검색 도구 초기화

```python
web_search = TavilySearchResults(max_results=2)
```

TavilySearchResults 객체를 생성합니다. `max_results` 매개변수를 2로 설정하여 최대 2개의 검색 결과만 반환하도록 합니다.

### 4. 검색 실행

```python
search_results = web_search.invoke(query)
```

`invoke` 메서드를 사용하여 실제 검색을 수행합니다. 검색 결과는 `search_results` 변수에 저장됩니다.

### 5. 검색 결과 출력

```python
for result in search_results:
	print(result)
	print("-",*100)
```

검색 결과를 순회하면서 각 결과를 출력합니다. 각 결과 사이에는 구분선을 추가하여 가독성을 높입니다. 전체 코드와 결과는 아래와 같습니다.

```python
from langchain_community.tools import TavilySearchResults

query = "2025년 애플의 주가 전망에 대해서 분석하세요."

web_search = TavilySearchResults(max_results=2)

search_results = web_search.invoke(query)

for result in search_results:
    print(result)
    print("-"*100)
```

```
실행 결과

{'title': 'AAPL - 애플 주가 전망 - Stockscan.io', 'url': 'https://stockscan.io/ko/stocks/AAPL/forecast', 'content': '### 2025, 2030, 2035, 2040, 2045 및 2050년 장기 AAPL 가격 예측\n\nBased on our analysis about 애플 financial reports and earnings history, 애플 (AAPL) stock could reach $299.14 by 2030, $1,221.47 by 2040 and $1,589.26 by 2050. See the projected annual prices until 2050 of the 애플 stock below:\n\n## 애플 주식 (AAPL) 연간 예측\n\n### 2025년을 위한 애플 주식 (AAPL) 가격 예측 [...] | 월 | 평균 | 저가 | 고가 | 오늘의 가격에서 변경 |\n| --- | --- | --- | --- | --- |\n| 7월, 2025 | $271.03 | $257.21 | $272.74 | +32.82% |\n| 8월, 2025 | $283.50 | $272.38 | $283.89 | +38.93% |\n| 9월, 2025 | $302.66 | $278.71 | $305.96 | +48.32% |\n| 10월, 2025 | $317.48 | $301.65 | $334.50 | +55.58% |\n| 11월, 2025 | $316.30 | $302.60 | $318.01 | +55.01% |\n| 12월, 2025 | $314.32 | $313.18 | $328.86 | +54.03% |\n\n### 2026년을 위한 애플 주식 (AAPL) 가격 예측', 'score': 0.91175514}
----------------------------------------------------------------------------------------------------
{'title': '애플 주식 가격 2025년, 2026년', 'url': 'https://wonforecast.com/apple', 'content': '2025년 08월의 . 시세는 202 달러 부터 시작하고 최대 239, 최소 202 으로 예측됩니다. 평균 219. 08월말의: 234.\n\n2025년 09월의 애플 주식 전망. 시세는 234 달러 부터 시작하고 최대 244, 최소 234 으로 예측됩니다. 평균 238. 09월말의: 239.\n\n2025년 10월의 . 시세는 239 달러 부터 시작하고 최대 239, 최소 228 으로 예측됩니다. 평균 235. 10월말의: 233.\n\n2025년 11월의 애플 주식 전망. 시세는 233 달러 부터 시작하고 최대 246, 최소 233 으로 예측됩니다. 평균 238. 11월말의: 241.\n\n2025년 12월의 . 시세는 241 달러 부터 시작하고 최대 241, 최소 222 으로 예측됩니다. 평균 233. 12월말의: 227.\n\n2026년 01월의 애플 주식 전망. 시세는 227 달러 부터 시작하고 최대 227, 최소 213 으로 예측됩니다. 평균 221. 01월말의: 217. [...] 2026년 02월의 . 시세는 217 달러 부터 시작하고 최대 217, 최소 196 으로 예측됩니다. 평균 208. 02월말의: 200.\n\n2026년 03월의 애플 주식 전망. 시세는 200 달러 부터 시작하고 최대 209, 최소 200 으로 예측됩니다. 평균 204. 03월말의: 205.\n\n아마존 주식 가격 2025년, 2026년.\n\n코스피 지수 전망, 2025, 2026.\n\n2026년 04월의 . 시세는 205 달러 부터 시작하고 최대 205, 최소 189 으로 예측됩니다. 평균 198. 04월말의: 193.\n\n2026년 05월의 애플 주식 전망. 시세는 193 달러 부터 시작하고 최대 208, 최소 193 으로 예측됩니다. 평균 200. 05월말의: 204.\n\n2026년 06월의 . 시세는 204 달러 부터 시작하고 최대 221, 최소 204 으로 예측됩니다. 평균 212. 06월말의: 217. [...] 09월 08일, 월요일의 : 235, 최대 240, 최소 230. 09월 09일, 화요일의 애플 주식 전망: 234, 최대 239, 최소 229. 09월 10일, 수요일의 : 235, 최대 240, 최소 230.\n\n## 2025년 그리고 2026년 애플 주식 가격 변동 전망\n\n### 매달애플 주식 가격', 'score': 0.8737439}
```

---

## 2.3 코드 인터프리터 도구 활용

이 예제는 LangChain 을 사용하여 Python 코드를 동적으로 생성하고 실행하는 코드 인터프리터를 구현합니다.

### 코드 실행 과정 설명

1. 모듈 가져오기
	- `PythonAstREPLTool` : Python 코드를 안전하게 실행하기 위한 도구
	- `initialize_agent`, `AgentType` : 에이전트 초기화 및 타입 설정
	- `ChatOpenAI` : OpenAI의 채팅 모델에 사용을 위한 클래스

2. REPL 도구 초기화 : `PythoAstREPLTool()`을 사용하여 Python 코드를 실행할 수 있는 환경을 생성합니다.

3. 언어 모델 초기화 : ChatOpenAI를 사용하여 GPT-4o-mini 모델을 초기화합니다. `temperature=0`은 가장 확실한 응답을 얻기 위한 설정입니다.

4. 에이전트 초기화 : `initialize_agent` 함수를 사용하여 에이전트를 설정합니다. 이 에이전트는 Python REPL 도구를 사용하여 작업을 수행합니다.

5. 작업 실행 : `agent.run()` 메소드를 사용하여 에이전트에게 작업을 지시합니다. 에이전트는 이 지시를 이해하고, Python 코드를 생성 및 실행한 후 결과를 설명합니다.

6. 결과 출력 : 에이전트의 작업 결과를 출력합니다.

전체 코드와 실행 결과는 다음과 같습니다. 우선 코드 실해에 있어 `langchain-experimental` 라이브러리 설치를 먼저 진행해 줍니다.

```
!pip install langchain-experimental
```

```python
# 코드 인터프리터 도구 활용 예제

# 필요한 모듈 가져오기
from langchain_experimental.tools import PythonAstREPLTool
from langchain.agents import initialize_agent, AgentType
from langchain.chat_models import ChatOpenAI

# Python 코드 실행을 위한 REPL 도구 초기화
python_repl = PythonAstREPLTool()

# OpenAI의 gpt-4o-mini 모델 초기화

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

# 에이전트 초기화
# ZERO_SHOT_REACT_DESCRIPTION 타입의 에이전트를 사용하며, verbose=True 로 설정하여 상세 출력을 얻습니다.

agent = initialize_agent(
    [python_repl], # 사용할 도구 리스트
    llm, # 사용할 언어 모델
    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, # 에이전트 타입
    verbose=True # 상세 출력 설정
)

# 에이전트에게 작업 지시 및 실행
result = agent.run("""
1부터 10까지의 숫자 중 짝수만 출력하는 Python 코드를 작성하고 실행해주세요.
그리고 그 결과를 설명해 주세요
""")

# 결과 출력
print(result)
```

```
실행 결과

> Entering new AgentExecutor chain...
To solve the problem, I need to write a Python code that generates even numbers from 1 to 10. The even numbers in this range are 2, 4, 6, 8, and 10. I will use a list comprehension or a loop to achieve this. After writing the code, I will execute it to see the output.

Action: python_repl_ast  
Action Input: `even_numbers = [num for num in range(1, 11) if num % 2 == 0]`  
Observation: 
Thought:I need to check the value of `even_numbers` to see the result of the code execution. 

Action: python_repl_ast  
Action Input: `even_numbers`  
Observation: [2, 4, 6, 8, 10]
Thought:I now know the final answer. The even numbers from 1 to 10 are [2, 4, 6, 8, 10].

Final Answer: 1부터 10까지의 숫자 중 짝수는 [2, 4, 6, 8, 10]입니다.

> Finished chain.
1부터 10까지의 숫자 중 짝수는 [2, 4, 6, 8, 10]입니다.
```


### 주의 사항

- 코드 실행 환경의 보안에 주의해야 합니다. `PythonAstREPLTool`은 기본적인 보안 기능을 제공하지만, 추가적인 보안 조치가 필요할 수 있습니다.
- 복잡한 연산이나 대규모 데이터를 다룰 때는 실행 시간과 리소스 사용에 주의해야 합니다.

---

## 2.4 SQL 데이터베이스 툴킷(Tool kit) 사용 - SQLite 예제

이 예제는 SQLite 데이터베이스와 LangChain 의 SQLDatabaseToolkit 을 사용하여 데이터베이스 쿼리를 수행하는 방법을 설명합니다.

### 주요 특징

- 인메모리 SQLite 데이터베이스 : Chinook 데이터베이스를 메모리에 로드하여 빠른 쿼리 실행이 가능합니다.
- LangChain SQLDatabaseToolkit : SQL 데이터베이스와의 상호작용을 쉽게 만들어줍니다.
- OpenAI GPT-4o-mini 모델 : 자연어 처리와 SQL 쿼리 생성에 사용됩니다.
- ReAct 에이전트 : 복잡한 쿼리를 단계별로 처리할 수 있는 에이전트를 생성합니다.

### 전체 과정

시작 전에 `langchain-openai` 와 `langgraph` 라이브러리 설치를 먼저 진행해 줍니다.

```
!pip install langchain-openai langgraph
```

1. 필요한 모듈 임포트

```python
import sqlite3
import requests
import os
import getpass
from sqlalchemy import create_engine
from sqlalchemy.pool import StaticPool
from langchain_community.utilities.sql_database import SQLDatabase
from langchain_openai import ChatOpenAI
from langchain_community.agent_toolkits.sql.toolkit import SQLDatabaseToolkit
from langchain import hub
from langgraph.prebuilt import create_react_agent

```

2. Chinook 데이터베이스 생성 함수

```python
# Chinook 데이터베이스 생성함수
def create_chinook_database():
  """Chinook 데이터베이스를 메모리에 생성하고 SQLAIchemy 엔진을 반환합니다."""
  url = "https://raw.githubusercontent.com/lerocha/chinook-database/master/ChinookDatabase/DataSources/Chinook_Sqlite.sql"
  response = requests.get(url)
  sql_script = response.text

  connection = sqlite3.connect(":memory:", check_same_thread=False)
  connection.executescript(sql_script)

  return create_engine(
      "sqlite://",
      creator=lambda: connection,
      poolclass = StaticPool,
      connect_args={"check_same_thrad":False},
  )
```

3. 데이터베이스 및 도구 설정

```python
# 데이터베이스 엔진 생성
db_engine = create_chinook_database()

#SQLDatabase 객체 생성
db = SQLDatabase(db_engine)

# OpenAI 의 gpt-4o-mini 모델 초기화
llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

# SQLDatabaseToolkit 객체 생성
toolkit = SQLDatabaseToolkit(db=db, llm=llm)
```

4. 에이전트 설정

```python
# 프롬프트 템플릿 가져오기
prompt_template = hub.pull("langchain-ai/sql-agent-system-prompt")

# 시스템 메시지 생성
system_message = prompt_template.format(dialect="SQLIte", top_k=5)

# ReAct 에이전트 생성
agent_executor = create_react_agent(
    llm,
    toolkit.get_tools(),
)
```

5. 쿼리 실행 및 결과 출력

```python
# 예제 쿼리 정의
example_query = "2009년에 가장 많이 팔린 장르는 무엇이며, 해당 장르의 총 매출액은 얼마인가요?"

# 에이전트를 사용하여 쿼리 실행
events = agent_executor.stream(
    {"messages" : [("system", system_message), ("user", example_query)]},
    stream_mode="values",
)

# 결과 출력
for event in events:
  event["messages"][-1].pretty_print()
```

실행 결과를 보면 "2009년에 가장 많이 팔린 장르와 해당 장르의 총 매출액"을 조회합니다. 에이전트는 이 질문을 이해하고, 적절한 SQL 쿼리를 생성하여 실행한 후, 결과를 사용자가 이해하기 쉬운 형태로 제공합니다.

````
실행 결과

================================ Human Message =================================

2009년에 가장 많이 팔린 장르는 무엇이며, 해당 장르의 총 매출액은 얼마인가요?
================================== Ai Message ==================================
Tool Calls:
  sql_db_list_tables (call_OPRRGAwVEk994Cd5bGPH1b7i)
 Call ID: call_OPRRGAwVEk994Cd5bGPH1b7i
  Args:
================================= Tool Message =================================
Name: sql_db_list_tables

Album, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track
================================== Ai Message ==================================
Tool Calls:
  sql_db_schema (call_S8uKAeH1I7wxctcapxsoHE9c)
 Call ID: call_S8uKAeH1I7wxctcapxsoHE9c
  Args:
    table_names: Genre, Invoice, InvoiceLine
  sql_db_schema (call_HgvJ3M4HjW6zWLuIguNPG4gC)
 Call ID: call_HgvJ3M4HjW6zWLuIguNPG4gC
  Args:
    table_names: Track
================================= Tool Message =================================
Name: sql_db_schema


CREATE TABLE "Track" (
	"TrackId" INTEGER NOT NULL, 
	"Name" NVARCHAR(200) NOT NULL, 
	"AlbumId" INTEGER, 
	"MediaTypeId" INTEGER NOT NULL, 
	"GenreId" INTEGER, 
	"Composer" NVARCHAR(220), 
	"Milliseconds" INTEGER NOT NULL, 
	"Bytes" INTEGER, 
	"UnitPrice" NUMERIC(10, 2) NOT NULL, 
	PRIMARY KEY ("TrackId"), 
	FOREIGN KEY("MediaTypeId") REFERENCES "MediaType" ("MediaTypeId"), 
	FOREIGN KEY("GenreId") REFERENCES "Genre" ("GenreId"), 
	FOREIGN KEY("AlbumId") REFERENCES "Album" ("AlbumId")
)

/*
3 rows from Track table:
TrackId	Name	AlbumId	MediaTypeId	GenreId	Composer	Milliseconds	Bytes	UnitPrice
1	For Those About To Rock (We Salute You)	1	1	1	Angus Young, Malcolm Young, Brian Johnson	343719	11170334	0.99
2	Balls to the Wall	2	2	1	U. Dirkschneider, W. Hoffmann, H. Frank, P. Baltes, S. Kaufmann, G. Hoffmann	342562	5510424	0.99
3	Fast As a Shark	3	2	1	F. Baltes, S. Kaufman, U. Dirkscneider & W. Hoffman	230619	3990994	0.99
*/
================================== Ai Message ==================================
Tool Calls:
  sql_db_query_checker (call_ajvj0j7ttPyVB2P5UnfV1MQk)
 Call ID: call_ajvj0j7ttPyVB2P5UnfV1MQk
  Args:
    query: SELECT g.Name AS Genre, SUM(i.Total) AS TotalSales 
FROM Invoice i 
JOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId 
JOIN Track t ON il.TrackId = t.TrackId 
JOIN Genre g ON t.GenreId = g.GenreId 
WHERE strftime('%Y', i.InvoiceDate) = '2009' 
GROUP BY g.Name 
ORDER BY TotalSales DESC 
LIMIT 5;
================================= Tool Message =================================
Name: sql_db_query_checker

```sql
SELECT g.Name AS Genre, SUM(i.Total) AS TotalSales 
FROM Invoice i 
JOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId 
JOIN Track t ON il.TrackId = t.TrackId 
JOIN Genre g ON t.GenreId = g.GenreId 
WHERE strftime('%Y', i.InvoiceDate) = '2009' 
GROUP BY g.Name 
ORDER BY TotalSales DESC 
LIMIT 5;
```
================================== Ai Message ==================================
Tool Calls:
  sql_db_query (call_uF16KBlYbuxfGszTReBwRsjU)
 Call ID: call_uF16KBlYbuxfGszTReBwRsjU
  Args:
    query: SELECT g.Name AS Genre, SUM(i.Total) AS TotalSales 
FROM Invoice i 
JOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId 
JOIN Track t ON il.TrackId = t.TrackId 
JOIN Genre g ON t.GenreId = g.GenreId 
WHERE strftime('%Y', i.InvoiceDate) = '2009' 
GROUP BY g.Name 
ORDER BY TotalSales DESC 
LIMIT 5;
================================= Tool Message =================================
Name: sql_db_query


================================== Ai Message ==================================

2009년에 가장 많이 팔린 장르는 "Rock"이며, 해당 장르의 총 매출액은 1,200.00 달러입니다.

````

---

# 3. 사용자 정의 도구

## LangChain 을 이용한 날시 정보 조회 에이전트 구현

이번 예제를 통해 LangChain 을 사용하여 외부 API 를 활용하는 커스텀 도구를 만들고, 이를 자연어 처리 에이전트와 통합하는 방법을 배워 봅니다. 구체적으로는 OpenWeatherMap API 를 통해 날씨 정보를 조회하는 커스텀 도구를 만들고, 이를 에이전트와 함께 사용하는 방법을 보여줍니다.

### 1. 커스텀 날씨 조회 도구 구현

```python
import os
import requests
from langchain_core.tools import tool

@tool
def get_weather(location: str) -> str:
    """주어진 위치의 현재 날씨 정보를 조회합니다."""
    # API 키 설정
    api_key = userdata.get('OPENWEATHERMAP_API_KEY')  # 구글 코랩 사용 시

    if not api_key:
        return "OpenWeatherMap API 키가 설정되지 않았습니다."

    base_url = "http://api.openweathermap.org/data/2.5/weather"

    # 입력 전처리
    location = location.strip("'\"")

    # API 요청 파라미터 설정
    params = {
        "q": location,
        "appid": api_key,
        "units": "metric"
    }

    try:
        # API 요청 및 응답 처리
        response = requests.get(base_url, params=params)
        response.raise_for_status()

        data = response.json()
        weather_description = data["weather"][0]["description"]
        temperature = data["main"]["temp"]
        return f"{location}의 현재 날씨: {weather_description}, 온도: {temperature}°C"
    except requests.exceptions.RequestException as e:
        return f"날씨 정보를 가져오는데 실패했습니다. 오류: {str(e)}"

```

위 코드는 `@tool` 데코레이터를 사용하여 `get_weather` 함수를 LangChain 도구로 등록합니다. 이 함수는 OpenWeatherMap API 를 사용하여 지정된 위치의 현재 날씨 정보를 조회합니다.

### 2. 에이전트 설정과 실행

```python
from langchain_openai import ChatOpenAI
from langchain.agents import initialize_agent, AgentType

# OpenAI의 GPT-4o-mini 모델 초기화
llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

# 에이전트 초기화
agent = initialize_agent(
    [get_weather],  # 커스텀 도구를 리스트에 추가
    llm,
    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
    verbose=True
)

```

OpenAI 의 gpt-4o-mini 모델을 사용하여 LLM 을 초기화하고, 이를 바탕으로 에이전트를 생성합니다. 에이전트는 ZERO_SHOT_REACT_DESCRIPTION 유형으로 설정되어 있으며, 앞서 정의한 `get_weather` 도구를 사용할 수 있습니다.

```python
# 에이전트에게 질문하기
response = agent.run("Seoul과 New York의 현재 날씨는 어떤가요?")
print(response)
```

마지막으로, 에이전트에게 서울과 뉴욕의 날씨에 대해 질문합니다. 에이전트는 이 질문을 이해하고, 필요에 따라 `get_weather` 도구를 두 번 호출하여 각 도시의 날씨 정보를 조회한 후, 결과를 종합하여 응답합니다.

```
실행 결과

> Entering new AgentExecutor chain...
Seoul과 New York의 현재 날씨를 알아보려면 두 도시의 날씨 정보를 각각 조회해야 합니다. 먼저 서울의 날씨를 확인하겠습니다.  
Action: get_weather  
Action Input: "Seoul"  
Observation: Seoul의 현재 날씨 : scattered clouds, 온도 : 29.76°C
Thought:Seoul의 날씨 정보를 확인했습니다. 이제 New York의 날씨를 조회하겠습니다.  
Action: get_weather  
Action Input: "New York"  
Observation: New York의 현재 날씨 : clear sky, 온도 : 22.77°C
Thought:I now know the final answer
Final Answer: 서울의 현재 날씨는 흐림이 약간 있는 상태이며, 온도는 29.76°C입니다. 뉴욕의 현재 날씨는 맑은 하늘이며, 온도는 22.77°C입니다.

> Finished chain.
서울의 현재 날씨는 흐림이 약간 있는 상태이며, 온도는 29.76°C입니다. 뉴욕의 현재 날씨는 맑은 하늘이며, 온도는 22.77°C입니다.
```

### 주의 사항

- OpenWeatherMap API 키가 필요하며 구글 코랩에서 사용 시에는 보안 비밀 창에서 API KEY 등록이 필요합니다.
- 도시 이름은 영어로 입력해야 정확한 결과를 얻을 수 있습니다.

# 4. 마치며

이렇게 LangChain 의 사용자 도구 사용까지해서 기본적인 LangChain 활용에 대해서 알아보았습니다. 이 이후에는 다른 교재를 찾아서 LangChain 심화 혹은 LangChain 과 비슷하 다른 프레임워크를 배워보고 그 프레임워크를 이용한 심화과정을 진행해 보고자 합니다. 이와 함께 프롬프트 엔지니어링까지 함께 진행하면서 이번과 같이 정리해서 포스트에 업로드 하고자 합니다. 긴 긁 읽어주셔서 감사드리며, 잘못된 내용 혹은 오타, 궁금하신게 있으시다면 댓글 달아주시기 바랍니다.